<!DOCTYPE html>
<!-- shadows.html
Bryce Melegari, Joe Knox
Created: 2017-11-20
Updated: 2017-12-13
HTML file for CS 381 Final Project

-->

<html>
<head>
<meta charset="utf-8">
<title>CS 381 - Final Project</title>
</head>
<body onload="main('maincanv')" style="overflow: hidden; margin: 0; padding: 0; background-color: #333">
<p style="text-align: center; color: #fff;">W/S: Tilt view up/down<br>
A/D: Increase/decrease scene rotation</p>
<canvas id="maincanv" style="display: block; margin: 0; padding: 0;"></canvas>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="quoll.js"></script>
<script type="text/javascript" src="qshapes.js"></script>
<script id="vertex_shader" type="x-shader/x-vertex">
//Default Vertex Shader
precision highp float;

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat3 normalMatrix;
uniform mat4 shadowmapMatrix;

attribute vec4 vertex_attr;
attribute vec4 color_attr;
attribute vec3 normal_attr;

varying vec4 paintcolor_var;
varying vec3 surfpt_var;
varying vec3 surfnorm_var;
varying vec4 vertex_rel_to_light;

void main()
{
    // Compute vertex position
    vec4 surfpt4 = modelViewMatrix * vertex_attr;
    surfpt_var = surfpt4.xyz / surfpt4.w;
    gl_Position = projectionMatrix * surfpt4;
    vertex_rel_to_light = shadowmapMatrix * vertex_attr;

    // Compute normal
    surfnorm_var = normalize(normalMatrix * normal_attr);

    // Send paint color to fragment shader
    paintcolor_var = color_attr;
}
</script>
<script id="fragment_shader" type="x-shader/x-fragment">
// Default Fragment Shader
precision highp float;

uniform vec4 lightpos_unif;
uniform sampler2D smap_sampler;

varying vec4 paintcolor_var;
varying vec3 surfpt_var;
varying vec3 surfnorm_var;
varying vec4 vertex_rel_to_light;

// inShadow
// Determine if this fragment is in shadow
bool inShadow() {
    // Take out of homogeneous form
    vec3 vertex_rel_to_light3 = vertex_rel_to_light.xyz / vertex_rel_to_light.w;
    // Normalize to [0, 1]
    vertex_rel_to_light3 = vertex_rel_to_light3 * 0.5 + 0.5;
    vec4 smap_color = texture2D(smap_sampler, vertex_rel_to_light3.xy);
    return vertex_rel_to_light3.z > smap_color.r;
}

// bpLight
// Compute color based on Blinn-Phong Illumination Model.
vec4 bpLight(
    vec4 lightcolor,
    vec4 lightpos4,  // Homogeneous form
    vec4 paintcolor,
    vec3 surfpt,
    vec3 surfnorm)
{
    // ***** Scalar Lighting Parameters *****

    float ambientfrac = 0.2;
        // Ambient light color, as fraction of light color
    float shininess = 200.;
        // Blinn-Phong Model shininess exponent

    // ***** Direction of Light Source (cam coords) *****
    vec3 lightdir;
    if (lightpos4.w == 0.)
        lightdir = normalize(lightpos4.xyz);
    else
        lightdir = normalize(lightpos4.xyz/lightpos4.w - surfpt);

    // ***** Compute the Three Parts of Blinn-Phong Model *****

    // Ambient
    vec4 ambientcolor = ambientfrac * lightcolor * paintcolor;
    //if (inShadow()) return clamp(ambientcolor, 0., 1.);

    // Diffuse
    // Lambert cosine (or 0 if this is negative)
    float lambertcos = max(0., dot(surfnorm, lightdir));
    vec4 diffusecolor = lambertcos * lightcolor * paintcolor;

    // Specular
    vec3 viewdir = normalize(-surfpt);
    vec3 halfway = normalize(viewdir + lightdir);
    float specularcoeff = pow(max(0., dot(surfnorm, halfway)),
                              4.*shininess);
        // Blinn-Phong needs shininiess 4 * [Phong shininess]
    vec4 specularcolor = specularcoeff * lightcolor;

    // ***** Combine the Three Parts *****
    if (inShadow()) return clamp(ambientcolor + diffusecolor + specularcolor, 0., 1.).gbra;
    return clamp(ambientcolor + diffusecolor + specularcolor, 0., 1.);
}

void main()
{
    // Surface normal
    vec3 surfnorm = normalize(surfnorm_var);

    // Light-source color
    vec4 lightcolor = vec4(1., 1., 1., 1.);  // White

    // Apply Blinn-Phong Illumination Model
    vec4 litcolor = bpLight(
        lightcolor,
        lightpos_unif,
        paintcolor_var,
        surfpt_var,
        surfnorm);

    // Send color to framebuffer
    gl_FragColor = vec4(litcolor.rgb, 1.0);
}
</script>
<script id="shadowmap_vertex_shader" type="x-shader/x-vertex">
// Shadowmap Vertex Shader
precision highp float;

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;

attribute vec4 vertex_attr;

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vertex_attr;
}
</script>
<script id="shadowmap_fragment_shader" type="x-shader/x-fragment">
// Shadowmap Fragment Shader
precision highp float;

void main() {
    float z = gl_FragCoord.z;
    gl_FragColor = vec4(z, z, z, 1.);
}
</script>
<script type="text/javascript" src="shadows.js"></script>

</body>
</html>
