<!DOCTYPE html>
<!-- shadows.html
Bryce Melegari, Joe Knox
Created: 2017-11-20
Updated: 2017-12-05
HTML file for CS 381 Final Project
Shaders and some setup code borrowed from Glenn G. Chappell -->
<html>
<head>
<meta charset="utf-8">
<title>CS 381 - Final Project</title>
</head>
<body onload="main('maincanv')" style="overflow: hidden; margin: 0; padding: 0; background-color: #333">
<p style="text-align: center; color: #fff;">W/S: Tilt view up/down<br>
A/D: Increase/decrease scene rotation</p>
<canvas id="maincanv" style="display: block; margin: 0; padding: 0;"></canvas>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="quoll.js"></script>

<!-- GLSL Shaders -->
<script id="vshader1" type="x-shader/x-vertex">
// Vertex Shader #1

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat3 normalMatrix;
uniform vec4 lightpos4_u;
uniform mat4 lightPOVMatrix;

attribute vec4 vertex_attr;
attribute vec4 color_attr;
attribute vec3 normal_attr;

varying vec4 paintcolor_var;
varying vec3 surfpt_var;
varying vec3 surfnorm_var;
varying vec4 lightpos4_var;
varying vec4 shadowCoord_var;

//in order for the shader to interpret the shadowmap, we have to sample the texture
//for each fragment. However, fragment coords are in [-1,1] while texture sampling
//is done in [0, 1]. We'll create this matrix to multiply by the MVP matrix to 
//make the comparison easier
const mat4 lightShiftMatrix = mat4(
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 0.5, 0.0,
	0.5, 0.5, 0.5, 1.0
	);
//this matrix divides coordinates by 2 and translates them appropriately.

void main()
{
    // Compute vertex position
    vec4 surfpt4 = modelViewMatrix * vertex_attr;
    surfpt_var = surfpt4.xyz / surfpt4.w;
    gl_Position = projectionMatrix * surfpt4;

    //send position of vertex in "light space" (as seen by the light)
    //--in a domain usable for texture sampling
    shadowCoord_var = lightShiftMatrix * lightPOVMatrix * vertex_attr;

    // Compute normal
    surfnorm_var = normalize(normalMatrix * normal_attr);

    // Send paint color to fragment shader
    paintcolor_var = color_attr;
    lightpos4_var = lightpos4_u;
}
</script>
<script id="fshader1" type="x-shader/x-fragment">
// Fragment Shader #1

#ifdef GL_ES
precision mediump float;
#endif

varying vec4 paintcolor_var;
varying vec3 surfpt_var;
varying vec3 surfnorm_var;
varying vec4 lightpos4_var;
varying vec4 shadowCoord_var;

uniform sampler2D shadowMap;

//decode the color back to depth data (undoes encodeFloat
//which is in the other fragment shader)
float decodeFloat(vec4 color) {
	//resurrect goat
	const vec4 bitShift = vec4(
		1. / (256.*256.*256.),
		1. / (256.*256.),
		1. / 256.,
		1.);
	return dot(color, bitShift);
}

// bpLight
// Compute color based on Blinn-Phong Illumination Model.
vec4 bpLight(
    vec4 lightcolor,
    vec4 lightpos4,  // Homogeneous form
    vec4 paintcolor,
    vec3 surfpt,
    vec3 surfnorm)
{
    // ***** Scalar Lighting Parameters *****

    float ambientfrac = 0.2;
        // Ambient light color, as fraction of light color
    float shininess = 200.;
        // PHONG Model shininess exponent
        // (Blinn-Phong needs 4 times larger)

    // ***** Direction of Light Source (cam coords) *****
    vec3 lightdir;
    if (lightpos4.w == 0.)
        lightdir = normalize(lightpos4.xyz);
    else
        lightdir = normalize(lightpos4.xyz/lightpos4.w - surfpt);

    // ***** Compute the Three Parts of Blinn-Phong Model *****

    // Ambient
    vec4 ambientcolor = ambientfrac * lightcolor * paintcolor;

    // Diffuse
    // Lambert cosine (or 0 if this is negative)
    float lambertcos = max(0., dot(surfnorm, lightdir));
    vec4 diffusecolor = lambertcos * lightcolor * paintcolor;

    // Specular
    vec3 viewdir = normalize(-surfpt);
    vec3 halfway = normalize(viewdir + lightdir);
    float specularcoeff = pow(max(0., dot(surfnorm, halfway)),
                              4.*shininess);
        // Blinn-Phong needs shininiess 4 * [Phong shininess]
    vec4 specularcolor = specularcoeff * lightcolor;

    // ***** Combine the Three Parts *****

    return clamp(ambientcolor + diffusecolor + specularcolor,
                 0., 1.);
}
void main()
{
    // Surface normal
    vec3 surfnorm = normalize(surfnorm_var);

    // Light-source color & position/direction
    vec4 lightcolor = vec4(1., 1., 1., 1.);  // White
    vec4 lightpos4 =  lightpos4_var;

    // Apply Blinn-Phong Illumination Model
    vec4 litcolor = bpLight(
        lightcolor,
        lightpos4,
        paintcolor_var,
        surfpt_var,
        surfnorm);

    //shadows:
  vec3 fragmentDepth = shadowCoord_var.xyz;
  // float shadowAcneRemover = 0.007;
  // fragmentDepth.z -= shadowAcneRemover;
  float visibility = 1.0;

    //float texelSize = 1. / 1024.;

    //test if current frag is in shadow
    float shadowDepth = decodeFloat(texture2D(shadowMap, fragmentDepth.xy));
    //float shadowDepth = texture2D(shadowMap, fragmentDepth.xy).r;
    //float shadowDepth = decodeFloat(texture2DProj(shadowMap, fragmentDepth));
   
    if( fragmentDepth.z > shadowDepth ) {
    	visibility = 0.5;
    }

    // Send color to framebuffer
    gl_FragColor = vec4(visibility * litcolor.rgb, 1.0);
    //gl_FragColor = vec4(shadowDepth, 0., 0., 1.);
    //gl_FragColor = vec4(fragmentDepth.z, 0., 0., 1.);


//cpy paste from example for testing:
  // vec3 fragmentDepth = shadowCoord_var.xyz;
  // float shadowAcneRemover = 0.007;
  // fragmentDepth.z -= shadowAcneRemover;

  // float texelSize = 1.0 / 1024.0;
  // float amountInLight = 0.0;

  // for (int x = -1; x <= 1; x++) {
  //   for (int y = -1; y <= 1; y++) {
  //     float texelDepth = decodeFloat(texture2D(shadowMap,
  //     fragmentDepth.xy + vec2(x, y) * texelSize));
  //     if (fragmentDepth.z < texelDepth) {
  //       amountInLight += 1.0;
  //     }
  //   }
  // }
  // amountInLight /= 9.0;

  // gl_FragColor = vec4(amountInLight * litcolor.rgb, 1.0);
  //end cpy paste

}
</script>

<!--vertex and fragment shaders for rendering the shadowmap-->
<script id="vshader2" type="x-shader/x-vertex">

	uniform mat4 mvpMatrix;

	attribute vec4 vertex_attr;

	void main() {
		gl_Position = mvpMatrix * vertex_attr;
	}
</script>

<script id="fshader2" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision mediump float;
	#endif

	//encode dapth values into a color value
	vec4 encodeFloat(float depth) {
		//sacrifice goat
		const vec4 bitShift = vec4(
			256.0*256.0*256.0,
			256.0*256.0,
			256.0,
			1.0);

		//align Qi
		const vec4 bitMask = vec4(
			0.0,
			1.0 / 256.0,
			1.0 / 256.0,
			1.0 / 256.0);

		//Cross streams!!!
		vec4 comp = fract(depth * bitShift);
		comp -= comp.xxyz * bitMask;
		return comp;
	}

	void main() {
		gl_FragColor = encodeFloat(gl_FragCoord.z);
		//gl_FragColor.r = gl_FragCoord.z;

	}
</script>

<!-- END GLSL Shaders -->

<!-- JavaScript Application -->
<script type="text/javascript">
// Globals

// WebGL General
var gl;                 // WebGL rendering context

// Shaders
var shaderprog1;        // Shader program object
var shaderprog2;		// Shader program used for shadowmaps

// object
var scene_rotate_ang;
var scene_rotate_spd;
var view_ang;
var lightDist;			//'distance' of sun
var lightPos; 			//position of 'sun'
var lightAngle;			//angle of the 'sun' in 2 dimensions from 'noon'

var lightModelViewProjectionMatrix; //MVP matrix from the perspective of the light source
var shadowMapTexture;

//shadowmap buffers
var fbo;
var rbo;

function makeShadowmapBuffers() {
	gl.useProgram(shaderprog2);
	fbo = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

	//we will use a texture to store the depth info for the shadowmap
	shadowMapTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, shadowMapTexture);

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texImage2D(gl.TEXTURE_2D, 0., gl.RGBA, 1024., 1024.,
		0., gl.RGBA, gl.UNSIGNED_BYTE, null);

	rbo = gl.createRenderbuffer();
	gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1024., 1024.);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, shadowMapTexture, 0.);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rbo);

	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
		console.log("shadow map framebuffer could not be created");
	}
}

function rendershadowmap() {
	gl.useProgram(shaderprog2);
	pushPMatrix(gl);
	gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	//gl.enable(gl.CULL_FACE);
	//gl.disable(gl.DEPTH_TEST);
	//we need to temporarily change the viewport, so we'll save the old one
	//and re-set that one when we're done
	var oldViewport = gl.getParameter(gl.VIEWPORT);
	gl.viewport(0., 0., 1024., 1024.);
	//gl.depthFunc(gl.GREATER);

	var lightProjectionMatrix = mat4.create();
	mat4.ortho(lightProjectionMatrix, -10., 10., -10., 10., 0., 20.);
	//mat4.perspective(lightProjectionMatrix, 90. * Math.PI/180., 16./9., 0., 100.);
	var lightViewMatrix = mat4.create();
	mat4.lookAt(lightViewMatrix, lightPos, [0., 0., 0.], [0., 1., 0.]);
	//model matrix is just the identity matrix
	mat4.mul(lightModelViewProjectionMatrix, lightProjectionMatrix, lightViewMatrix);
	
    //gl.clearColor(0., 0., 0., 1.);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    //send matrix to shader
    var matrixLoc = gl.getUniformLocation(shaderprog2, 'mvpMatrix');
    gl.uniformMatrix4fv(matrixLoc, false, lightModelViewProjectionMatrix);

    drawScene();

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    //reset viewport
    gl.viewport(oldViewport[0], oldViewport[1], oldViewport[2], oldViewport[3]);
    //gl.enable(gl.DEPTH_TEST);
    //gl.depthFunc(gl.LESS);
    popPMatrix(gl);
}

// main function
// Sets up GL, shaders, callbacks, and handlers
function main(canvasid) {
    // Initialize quoll.js & WebGL
    gl = quollInit(canvasid);
    if (!gl) return;  // Could not intialize; exit

    //WebGL extensions for depth textures
    var ext1 = gl.getExtension('WEBGL_depth_texture');
    var ext2 = gl.getExtension('OES_texture_float');

    // Shaders
    shaderprog1 = makeProgramObjectFromIds(gl, 'vshader1', 'fshader1');
    shaderprog2 = makeProgramObjectFromIds(gl, 'vshader2', 'fshader2');


    // Register callbacks with quoll.js
    registerDisplay(display);
    registerReshape(reshape);
    registerIdle(idle);
    canvasFullWindow(true);

    // Set up other event handlers
    document.addEventListener('keypress', keyboard, false);

    // object init
    scene_rotate_ang = 0.;
    scene_rotate_spd = 0.;
    view_ang = 25.;
    lightDist = 5.;
    lightPos = vec4.fromValues(0., lightDist, 0., 0.);
    lightAngle = 0.;
    lightModelViewProjectionMatrix = mat4.create();

    // GL States
    gl.enable(gl.DEPTH_TEST);
    makeShadowmapBuffers();
}


// drawCircle
// draws a circle with given number of slices
function drawCircle(ctx, subdivs, r, g, b, a) {
    pushMvMatrix(ctx);
    primBegin(ctx, ctx.TRIANGLE_FAN);
    primColor(ctx, r, g, b, a);
    primNormal(ctx, 0., 0., -1.);
    primVertex(ctx, 0., 0.);
    for (var ii = 0; ii <= subdivs; ++ii) {
        primVertex(ctx,
            Math.sin(2.*Math.PI*ii/subdivs),
            Math.cos(2.*Math.PI*ii/subdivs));
    }
    primEnd(ctx);
    popMvMatrix(ctx);
}

// drawCone
// draws an open cone
function drawCone(ctx, subdivs, r, g, b, a) {
	pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 0., 1.]);
	var stepSize = 2.*Math.PI/subdivs;
	for(var ii = 0; ii < subdivs; ++ii) {
        primBegin(ctx, ctx.TRIANGLES);
        primColor(ctx, r, g, b, a);
        var point1 = vec3.fromValues(1., 0., 0.);
        var point2 = vec3.fromValues(0.,
            Math.sin(ii*2.*Math.PI/subdivs),
            Math.cos(ii*2.*Math.PI/subdivs));
        var point3 = vec3.fromValues(0.,
            Math.sin((ii+1)*2.*Math.PI/subdivs),
            Math.cos((ii+1)*2.*Math.PI/subdivs));
        // calculate facet normal
        var side1 = vec3.create();
        vec3.subtract(side1, point1, point2);
        var side2 = vec3.create();
        vec3.subtract(side2, point1, point3);
        var normal = vec3.create();
        vec3.cross(normal, side2, side1);
        vec3.normalize(normal, normal);
        primNormal(ctx, normal[0], normal[1], normal[2]);
        primVertex(ctx, point1[0], point1[1], point1[2]);
        primVertex(ctx, point2[0], point2[1], point2[2]);
        primVertex(ctx, point3[0], point3[1], point3[2]);
        primEnd(ctx);
	}
	popMvMatrix(ctx);
}

// drawClosedCylinder
// draws a cylinder with closed ends
function drawClosedCylinder(ctx, subdivs, r, g, b, a) {
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 0., 1.]);
    // draw the open cylinder
    drawCylinder(ctx, subdivs, r, g, b, a);
    
    // draw the top circle
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, -Math.PI/2., [0., 1., 0.]);
    mat4.translate(ctx.mvMatrix, ctx.mvMatrix, [0., 0., -1.]);
    drawCircle(ctx, 4*subdivs, r, g, b, a);
    popMvMatrix(ctx);
    
    // draw the bottom circle
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 1., 0.]);
    mat4.translate(ctx.mvMatrix, ctx.mvMatrix, [0., 0., -1.]);
    drawCircle(ctx, 4*subdivs, r, g, b, a);
    popMvMatrix(ctx);
    popMvMatrix(ctx);
}

// drawRing
// draws an annulus, with radii 1 and given
function drawRing(ctx, subdivs, rad, r, g, b, a) {
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [1., 0., 0.]);
    primBegin(ctx, ctx.TRIANGLE_STRIP);
    primColor(ctx, r, g, b, a);
    primNormal(ctx, 0., 0., -1.);
    for (var ii = 0; ii <= 4*subdivs; ++ii) {
        primVertex(ctx,
            Math.sin(0.5*Math.PI*ii/subdivs),
            Math.cos(0.5*Math.PI*ii/subdivs));
        primVertex(ctx,
            Math.sin(0.5*Math.PI*ii/subdivs)*rad,
            Math.cos(0.5*Math.PI*ii/subdivs)*rad);
    }
    primEnd(ctx);
    popMvMatrix(ctx);
}

// drawPipe
// draws a closed annular prism, with radii 1 and given
function drawPipe(ctx, subdivs, rad, r, g, b, a) {
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 0., 1.]);
    drawCylinder(ctx, subdivs, r, g, b, a);
    popMvMatrix(ctx);
    
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 0., 1.]);
    mat4.scale(ctx.mvMatrix, ctx.mvMatrix, [1., rad, rad]);
    drawCylinder(ctx, subdivs, r, g, b, a);
    popMvMatrix(ctx);
    
    pushMvMatrix(ctx);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    drawRing(ctx, subdivs, rad, r, g, b, a);
    popMvMatrix(ctx);
    
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI, [-1., 0., 0.]);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    drawRing(ctx, subdivs, rad, r, g, b, a);
    popMvMatrix(ctx);
}

// drawGround function
// draws the ground and road
function drawGround() {
    // draws the grass field
    pushMvMatrix(gl);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [8., 1., 8.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, Math.PI/2., [1., 0., 0.]);
    drawSquare(gl, 10., 0.4, 0.8, 0.4, 1.);
   //drawCircle(gl, 80, 0., 0.5, 0., 1.0);
    popMvMatrix(gl);
    
    // draws the roadway
    // pushMvMatrix(gl);
    // mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0.001, 0.]);
    // mat4.scale(gl.mvMatrix, gl.mvMatrix, [6., 1., 6.]);
    // drawRing(gl, 40, 0.5, 0.1, 0.1, 0.1, 1.0);
    // popMvMatrix(gl);
    
    // // draws the outer road line
    // pushMvMatrix(gl);
    // mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0.002, 0.]);
    // mat4.scale(gl.mvMatrix, gl.mvMatrix, [5.8, 1., 5.8]);
    // drawRing(gl, 40, 0.98, 0.8, 0.8, 0.8, 1.0);
    // popMvMatrix(gl);
    
    // // draws the inner road line
    // pushMvMatrix(gl);
    // mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0.002, 0.]);
    // mat4.scale(gl.mvMatrix, gl.mvMatrix, [3.2, 1., 3.2]);
    // drawRing(gl, 40, 0.98, 0.8, 0.8, 0., 1.0);
    // popMvMatrix(gl);
}

// drawFountain function
// draws the fountain in the center of the roundabout
function drawFountain() {
    pushMvMatrix(gl);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [0.8, 0.1, 0.8]);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    drawClosedCylinder(gl, 40, 0.8, 0.8, 0.8, 1.0);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [1.2, 1., 1.2]);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 2., 0.]);
    drawPipe(gl, 40, 0.6, 0.8, 0.8, 0.8, 1.0);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, Math.PI/2., [1., 0., 0.]);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [0.7, 0.7, 1.0]);
    drawCircle(gl, 40, 0.4, 0.4, 1.0, 1.0);
    popMvMatrix(gl);
}

// drawScene function
// draws everything
function drawScene() {
    pushMvMatrix(gl);
    drawGround();
    //drawFountain();

    pushMvMatrix(gl);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [3., 3., 3.]);
    popMvMatrix(gl);

    // pushMvMatrix(gl);
    // mat4.translate(gl.mvMatrix, gl.mvMatrix, lightPos);
    // drawSphere(gl, .2, 10., 10., 1., 1., 1., 1.)
    // popMvMatrix(gl);
    //drawPipe(gl, 1, 1.5, 0.8, 0.8, 0.8, 1.0);
    // pushMvMatrix(gl);
    	//mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    	//drawCube(gl, 0.5, 0.8, 0.8, 0.8, 1.);
    	//drawClosedCylinder(gl, 40, 0.8, 0.8, 0.8, 1.0);
    pushMvMatrix(gl);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    drawSphere(gl, 1., 100., 100., 1., 1., 1., 1.);
    popMvMatrix(gl);
    // popMvMatrix(gl);
    popMvMatrix(gl);
}

// display function
// shows the objects on the scwreen
function display() {
	rendershadowmap();
    gl.useProgram(shaderprog1);

    var sampler_loc = gl.getUniformLocation(shaderprog1, 'shadowMap');
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, shadowMapTexture);
    //gl.uniform1i(sampler_loc, 0);

    //send light position to shader
    var lightpos4_u_loc = gl.getUniformLocation(shaderprog1, 'lightpos4_u');
    gl.uniform4fv(lightpos4_u_loc, lightPos);
    //send light MVP matrix to shader
    var lightMVP_loc = gl.getUniformLocation(shaderprog1, 'lightPOVMatrix');
    gl.uniformMatrix4fv(lightMVP_loc, false, lightModelViewProjectionMatrix)

    gl.clearColor(0.2, 0.2, 0.2, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Camera transformation
    mat4.identity(gl.mvMatrix);
    //mat4.mul(gl.mvMatrix, lightModelViewProjectionMatrix, gl.mvMatrix);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0., -8.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, view_ang * Math.PI/180., [1., 0., 0.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, scene_rotate_ang * Math.PI/180., [0., -1., 0.]);

    //light position change	
    radianLightAngle = lightAngle * Math.PI/180.;		//WORKING HERRE
    //vec4.set(lightPos, lightDist * Math.cos(radianLightAngle), lightDist * Math.sin(radianLightAngle), 0., 0.);
    //vec4.set(lightPos, lightDist * Math.cos(radianLightAngle), lightDist * Math.sin(radianLightAngle), 0., 1.);

    // draw all the things
    drawScene();
    gl.flush();
}

// reshape function
// manages viewport and projection
function reshape(w, h) {
    // Set up viewport
    gl.viewport(0, 0, w, h);

    // Set up projection
    mat4.perspective(gl.pMatrix,
                     Math.PI/180. * 60.,  // y field-of-view angle
                     w/h,                 // Viewport aspect ratio
                     0.1, 20.);           // Near & far distances
}

// idle function
// manages idle animation of the scene
function idle() {
    var elapsed_time = getElapsedTime(0.1);
    scene_rotate_ang += scene_rotate_spd * elapsed_time;
    
    //rotate 'sun' around the scene
    lightAngle += 0.1;

    postRedisplay();
}

// keyboard function
// takes input from the keyboard
function keyboard(event) {
    var key = keyFromEvent(event);

    switch (key) {
    // move camera up and down
    case 'W':
    case 'w':
        //if (view_ang > 1)
            view_ang -= 1;
        postRedisplay();
        break;
    case 'S':
    case 's':
        //if (view_ang < 90)
            view_ang += 1;
        postRedisplay();
        break;

    // adjust left-right spin speed
    case 'D':
    case 'd':
        if (scene_rotate_spd > -200) scene_rotate_spd -= 5;
        postRedisplay();
        break;
    case 'A':
    case 'a':
        if (scene_rotate_spd < 200) scene_rotate_spd += 5;
        postRedisplay();
        break;
    default:
        break;
    }
}
</script>
</body>
</html>
