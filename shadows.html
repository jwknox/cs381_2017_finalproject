<!DOCTYPE html>
<!-- shadows.html
Bryce Melegari, Joe Knox
Created: 2017-11-20
Updated: 2017-11-20
HTML file for CS 381 Final Project
Shaders and some setup code borrowed from Glenn G. Chappell -->
<html>
<head>
<meta charset="utf-8">
<title>CS 381 - Final Project</title>
</head>
<body onload="main('maincanv')" style="overflow: hidden; margin: 0; padding: 0; background-color: #333">
<p style="text-align: center; color: #fff;">W/S: Tilt view up/down<br>
A/D: Increase/decrease scene rotation</p>
<canvas id="maincanv" style="display: block; margin: 0; padding: 0;"></canvas>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="quoll.js"></script>

<!-- GLSL Shaders -->
<script id="vshader1" type="x-shader/x-vertex">
// Vertex Shader #1

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat3 normalMatrix;

attribute vec4 vertex_attr;
attribute vec4 color_attr;
attribute vec3 normal_attr;

varying vec4 paintcolor_var;
varying vec3 normal_var;

void main()
{
    // Compute projected vertex position
    gl_Position = projectionMatrix * modelViewMatrix * vertex_attr;

    // Send paint color and normal to fragment shader
    paintcolor_var = color_attr;
    normal_var = normalize(normalMatrix * normal_attr);
}
</script>
<script id="fshader1" type="x-shader/x-fragment">
// Fragment Shader #1

#ifdef GL_ES
precision mediump float;
#endif

varying vec4 paintcolor_var;
varying vec3 normal_var;

void main()
{
    // light direction - kind of up to the left
    vec3 light_dir = normalize(vec3(-1., -1., 1.));
    
    // calculate lit color
    vec4 final_color = paintcolor_var;
    float view_cos = dot(normal_var, light_dir);
    if (view_cos > 0.) final_color += view_cos/3.; // wrong, but works
    clamp(final_color, 0., 1.);
    gl_FragColor = final_color;
}
</script>
<!-- END GLSL Shaders -->

<!-- JavaScript Application -->
<script type="text/javascript">
// Globals

// WebGL General
var gl;                 // WebGL rendering context

// Shaders
var shaderprog1;        // Shader program object

// object
var scene_rotate_ang;
var scene_rotate_spd;
var view_ang;

// main function
// Sets up GL, shaders, callbacks, and handlers
function main(canvasid) {
    // Initialize quoll.js & WebGL
    gl = quollInit(canvasid);
    if (!gl) return;  // Could not intialize; exit

    // Shaders
    shaderprog1 = makeProgramObjectFromIds(gl, 'vshader1', 'fshader1');

    // Register callbacks with quoll.js
    registerDisplay(display);
    registerReshape(reshape);
    registerIdle(idle);
    canvasFullWindow(true);

    // Set up other event handlers
    document.addEventListener('keypress', keyboard, false);

    // object init
    scene_rotate_ang = 90.;
    scene_rotate_spd = 15;
    view_ang = 25.;

    // GL States
    gl.enable(gl.DEPTH_TEST);
}

// drawScene function
// draws everything
function drawScene() {
    pushMvMatrix(gl);
    // TODO: DRAW ALL THE THINGS
    drawCube(gl, 2., 0.4, 0.4, 0.4, 1.0);
    popMvMatrix(gl);
}

// display function
// shows the objects on the screen
function display() {
    gl.useProgram(shaderprog1);

    gl.clearColor(0.2, 0.2, 0.2, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Camera transformation
    mat4.identity(gl.mvMatrix);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0., -4.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, view_ang * Math.PI/180., [1., 0., 0.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, scene_rotate_ang * Math.PI/180., [0., -1., 0.]);

    // draw all the things
    drawScene();

    gl.flush();
}

// reshape function
// manages viewport and projection
function reshape(w, h) {
    // Set up viewport
    gl.viewport(0, 0, w, h);

    // Set up projection
    mat4.perspective(gl.pMatrix,
                     Math.PI/180. * 60.,  // y field-of-view angle
                     w/h,                 // Viewport aspect ratio
                     0.1, 20.);           // Near & far distances
}

// idle function
// manages idle animation of the scene
function idle() {
    var elapsed_time = getElapsedTime(0.1);
    scene_rotate_ang += scene_rotate_spd * elapsed_time;
    postRedisplay();
}

// keyboard function
// takes input from the keyboard
function keyboard(event) {
    var key = keyFromEvent(event);

    switch (key) {
    // move camera up and down
    case 'W':
    case 'w':
        if (view_ang > 1) view_ang -= 1;
        postRedisplay();
        break;
    case 'S':
    case 's':
        if (view_ang < 90) view_ang += 1;
        postRedisplay();
        break;

    // adjust left-right spin speed
    case 'D':
    case 'd':
        if (scene_rotate_spd > -200) scene_rotate_spd -= 5;
        postRedisplay();
        break;
    case 'A':
    case 'a':
        if (scene_rotate_spd < 200) scene_rotate_spd += 5;
        postRedisplay();
        break;
    default:
        break;
    }
}
</script>
</body>
</html>
