<!DOCTYPE html>
<!-- shadows.html
Bryce Melegari, Joe Knox
Created: 2017-11-20
Updated: 2017-11-20
HTML file for CS 381 Final Project
Shaders and some setup code borrowed from Glenn G. Chappell -->
<html>
<head>
<meta charset="utf-8">
<title>CS 381 - Final Project</title>
</head>
<body onload="main('maincanv')" style="overflow: hidden; margin: 0; padding: 0; background-color: #333">
<p style="text-align: center; color: #fff;">W/S: Tilt view up/down<br>
A/D: Increase/decrease scene rotation</p>
<canvas id="maincanv" style="display: block; margin: 0; padding: 0;"></canvas>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="quoll.js"></script>

<!-- GLSL Shaders -->
<script id="vshader1" type="x-shader/x-vertex">
// Vertex Shader #1w

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat3 normalMatrix;

attribute vec4 vertex_attr;
attribute vec4 color_attr;
attribute vec3 normal_attr;

varying vec4 paintcolor_var;
varying vec3 normal_var;

void main()
{
    // Compute projected vertex position
    gl_Position = projectionMatrix * modelViewMatrix * vertex_attr;

    // Send paint color and normal to fragment shader
    paintcolor_var = color_attr;
    normal_var = normalize(normalMatrix * normal_attr);
}
</script>
<script id="fshader1" type="x-shader/x-fragment">
// Fragment Shader #1

#ifdef GL_ES
precision mediump float;
#endif

varying vec4 paintcolor_var;
varying vec3 normal_var;

void main()
{
    // light direction - straight down
    vec3 light_dir = normalize(vec3(0., 1., 0.));
    
    // calculate lit color
    vec4 final_color = paintcolor_var;
    float view_cos = dot(normal_var, light_dir);
    if (view_cos > 0.) final_color += view_cos/3.; // wrong, but works
    clamp(final_color, 0., 1.);
    gl_FragColor = final_color;
}
</script>
<!-- END GLSL Shaders -->

<!-- JavaScript Application -->
<script type="text/javascript">
// Globals

// WebGL General
var gl;                 // WebGL rendering context

// Shaders
var shaderprog1;        // Shader program object

// object
var scene_rotate_ang;
var scene_rotate_spd;
var view_ang;

// main function
// Sets up GL, shaders, callbacks, and handlers
function main(canvasid) {
    // Initialize quoll.js & WebGL
    gl = quollInit(canvasid);
    if (!gl) return;  // Could not intialize; exit

    // Shaders
    shaderprog1 = makeProgramObjectFromIds(gl, 'vshader1', 'fshader1');

    // Register callbacks with quoll.js
    registerDisplay(display);
    registerReshape(reshape);
    registerIdle(idle);
    canvasFullWindow(true);

    // Set up other event handlers
    document.addEventListener('keypress', keyboard, false);

    // object init
    scene_rotate_ang = 0.;
    scene_rotate_spd = 0.;
    view_ang = 25.;

    // GL States
    gl.enable(gl.DEPTH_TEST);
}

// drawCircle
// draws a circle with given number of slices
function drawCircle(ctx, subdivs, r, g, b, a) {
    pushMvMatrix(ctx);
    primBegin(ctx, ctx.TRIANGLE_FAN);
    primColor(ctx, r, g, b, a);
    primNormal(ctx, 0., 0., -1.);
    primVertex(ctx, 0., 0.);
    for (var ii = 0; ii <= subdivs; ++ii) {
        primVertex(ctx,
            Math.sin(2.*Math.PI*ii/subdivs),
            Math.cos(2.*Math.PI*ii/subdivs));
    }
    primEnd(ctx);
    popMvMatrix(ctx);
}

//drawCone
//draws an open cone
function drawCone(ctx, subdivs, r, g, b, a) {
	pushMvMatrix(ctx);
	primBegin(ctx, ctx.TRIANGLE_FAN);
	primColor(ctx, r, g, b, a);
	primNormal(ctx, 0., 0., -1.);
	primVertex(ctx, 0., 1., 0.);
	var stepSize = 2.*Math.PI/subdivs;
	for(var i = 0; i <= subdivs; ++i) {
		primVertex(ctx,
			Math.cos(i*stepSize), 0., Math.sin(i*stepSize));
	}
	primEnd(ctx);
	popMvMatrix(ctx);
}

// drawClosedCylinder
// draws a cylinder with closed ends
function drawClosedCylinder(ctx, subdivs, r, g, b, a) {
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 0., 1.]);
    // draw the open cylinder
    drawCylinder(ctx, subdivs, r, g, b, a);
    
    // draw the top circle
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, -Math.PI/2., [0., 1., 0.]);
    mat4.translate(ctx.mvMatrix, ctx.mvMatrix, [0., 0., -1.]);
    drawCircle(ctx, 4*subdivs, r, g, b, a);
    popMvMatrix(ctx);
    
    // draw the bottom circle
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 1., 0.]);
    mat4.translate(ctx.mvMatrix, ctx.mvMatrix, [0., 0., -1.]);
    drawCircle(ctx, 4*subdivs, r, g, b, a);
    popMvMatrix(ctx);
    popMvMatrix(ctx);
}

// drawRing
// draws an annulus, with radii 1 and given
function drawRing(ctx, subdivs, rad, r, g, b, a) {
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [1., 0., 0.]);
    primBegin(ctx, ctx.TRIANGLE_STRIP);
    primColor(ctx, r, g, b, a);
    primNormal(ctx, 0., 0., -1.);
    for (var ii = 0; ii <= 4*subdivs; ++ii) {
        primVertex(ctx,
            Math.sin(0.5*Math.PI*ii/subdivs),
            Math.cos(0.5*Math.PI*ii/subdivs));
        primVertex(ctx,
            Math.sin(0.5*Math.PI*ii/subdivs)*rad,
            Math.cos(0.5*Math.PI*ii/subdivs)*rad);
    }
    primEnd(ctx);
    popMvMatrix(ctx);
}

// drawPipe
// draws a closed annular prism, with radii 1 and given
function drawPipe(ctx, subdivs, rad, r, g, b, a) {
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 0., 1.]);
    drawCylinder(ctx, subdivs, r, g, b, a);
    popMvMatrix(ctx);
    
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI/2., [0., 0., 1.]);
    mat4.scale(ctx.mvMatrix, ctx.mvMatrix, [1., rad, rad]);
    drawCylinder(ctx, subdivs, r, g, b, a);
    popMvMatrix(ctx);
    
    pushMvMatrix(ctx);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    drawRing(ctx, subdivs, rad, r, g, b, a);
    popMvMatrix(ctx);
    
    pushMvMatrix(ctx);
    mat4.rotate(ctx.mvMatrix, ctx.mvMatrix, Math.PI, [-1., 0., 0.]);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    drawRing(ctx, subdivs, rad, r, g, b, a);
    popMvMatrix(ctx);
}

// drawGround function
// draws the ground and road
function drawGround() {
    // draws the grass field
    pushMvMatrix(gl);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [8., 1., 8.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, Math.PI/2., [1., 0., 0.]);
    drawCircle(gl, 80, 0., 0.5, 0., 1.0);
    popMvMatrix(gl);
    
    // draws the roadway
    pushMvMatrix(gl);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0.001, 0.]);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [6., 1., 6.]);
    drawRing(gl, 40, 0.5, 0.1, 0.1, 0.1, 1.0);
    popMvMatrix(gl);
    
    // draws the outer road line
    pushMvMatrix(gl);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0.002, 0.]);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [5.8, 1., 5.8]);
    drawRing(gl, 40, 0.98, 0.8, 0.8, 0.8, 1.0);
    popMvMatrix(gl);
    
    // draws the inner road line
    pushMvMatrix(gl);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0.002, 0.]);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [3.2, 1., 3.2]);
    drawRing(gl, 40, 0.98, 0.8, 0.8, 0., 1.0);
    popMvMatrix(gl);
}

// drawFountain function
// draws the fountain in the center of the roundabout
function drawFountain() {
    pushMvMatrix(gl);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [0.8, 0.1, 0.8]);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 1., 0.]);
    drawClosedCylinder(gl, 40, 0.8, 0.8, 0.8, 1.0);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [1.2, 1., 1.2]);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 2., 0.]);
    drawPipe(gl, 40, 0.6, 0.8, 0.8, 0.8, 1.0);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, Math.PI/2., [1., 0., 0.]);
    mat4.scale(gl.mvMatrix, gl.mvMatrix, [0.7, 0.7, 1.0]);
    drawCircle(gl, 40, 0.4, 0.4, 1.0, 1.0);
    popMvMatrix(gl);
}

// drawScene function
// draws everything
function drawScene() {
    pushMvMatrix(gl);
    drawGround();
    drawFountain();
    popMvMatrix(gl);
}

// display function
// shows the objects on the screen
function display() {
    gl.useProgram(shaderprog1);

    gl.clearColor(0.2, 0.2, 0.2, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Camera transformation
    mat4.identity(gl.mvMatrix);
    mat4.translate(gl.mvMatrix, gl.mvMatrix, [0., 0., -8.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, view_ang * Math.PI/180., [1., 0., 0.]);
    mat4.rotate(gl.mvMatrix, gl.mvMatrix, scene_rotate_ang * Math.PI/180., [0., -1., 0.]);

    // draw all the things
    drawScene();
    gl.flush();
}

// reshape function
// manages viewport and projection
function reshape(w, h) {
    // Set up viewport
    gl.viewport(0, 0, w, h);

    // Set up projection
    mat4.perspective(gl.pMatrix,
                     Math.PI/180. * 60.,  // y field-of-view angle
                     w/h,                 // Viewport aspect ratio
                     0.1, 20.);           // Near & far distances
}

// idle function
// manages idle animation of the scene
function idle() {
    var elapsed_time = getElapsedTime(0.1);
    scene_rotate_ang += scene_rotate_spd * elapsed_time;
    postRedisplay();
}

// keyboard function
// takes input from the keyboard
function keyboard(event) {
    var key = keyFromEvent(event);

    switch (key) {
    // move camera up and down
    case 'W':
    case 'w':
        if (view_ang > 1)
            view_ang -= 1;
        postRedisplay();
        break;
    case 'S':
    case 's':
        if (view_ang < 90)
            view_ang += 1;
        postRedisplay();
        break;

    // adjust left-right spin speed
    case 'D':
    case 'd':
        if (scene_rotate_spd > -200) scene_rotate_spd -= 5;
        postRedisplay();
        break;
    case 'A':
    case 'a':
        if (scene_rotate_spd < 200) scene_rotate_spd += 5;
        postRedisplay();
        break;
    default:
        break;
    }
}
</script>
</body>
</html>
